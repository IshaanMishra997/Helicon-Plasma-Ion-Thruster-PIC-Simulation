#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Jan 28 15:48:59 2021
@author: ishaanmishra
PIC simulation of hybrid plasma + gridded thruster 
"""
import numpy as np
import random
import math
import time
import pylab as pl 

start_time = time.time()


#------------------------------SETUP_DEFINITION------------------------------#


T = 5500 #temperature of cold plasma in Kelvin
Kb = 1.38064852e-23 # Boltzmann's constant
eps0 = 8.854187817e-12
q = 1.602176634e-19 
me = 9.10938356e-31
eV_to_J = 1.60218e-19

n0 = 1e18
phi0 = 0

s=input("""Choose propellant (input: 1,2,3): 
    1) Helium
    2) Argon
    3) Xenon""")

if s=='1':
    mi = 6.6464731e-27 #mass of helium atom in kg
    print('Helium')
elif s=='2':
    mi = 6.6335209e-26 #mass of argon atom in kg
    print('Argon')
elif s=='3':
    mi = 2.1801714e-25 #mass of xenon atom in kg
    print('Xenon')

vth_i = (3*Kb*T/mi)**(1/2) 
print("Thermal velocity of ions: ",round(vth_i,2), "m/s")

dt = 5e-8
spwt=10000000

pdot=int(n0*(np.pi*(0.015**2)/2)*vth_i*dt/spwt) # number of ions added per time step (dt)


#class definition
class Particle:
    def __init__(self,pos,vel):
        self.pos=[pos[0],pos[1]]    #xy position
        self.vel=[vel[0],vel[1]]    #xy velocity
        self.icrhcheck = False

class Species: 
    def __init__(self, mass, spwt, charge, vth):
        self.mass = mass*spwt
        self.charge = q*spwt
        self.l = []
        self.vth = vth
        self.spwt = spwt


#------------------------------MESH DEFINITION-------------------------------#


tlen = 1.101 #total length of thruster section in metres 
thei = 0.265 #total height of thruster section in metres 
gx = 1e-3 #electrostatic grid width in metres
nodeno = 0 

def yval(x): 
    if x<=0.5: 
        return 1.5e-2
    elif x<=1.10: 
        return 1.5e-2 + 5/12*(x-0.5) #5/12 is the slope of the nozzle 
    elif x<= 1.101: 
        return 1.5e-2 + 5/12*(1.1-0.5)


ld = (eps0*Kb*T/(n0*q*q))**(1/2)
print('debye length: ', round(ld,8), 'm')

dx = 5e-3
dy = 5e-3

nx= int(tlen/dx)
ny = int(thei/dy)

mesh=[]
for i in range(nx): 
    lx = [] 
    for j in range(ny): 
        lx.append(0)
    mesh.append(lx)

nx_a = int(0.5/dx)
ny_a = int(0.015/dy)

nx_b = int(tlen/dx)
ny_b = int()

#volume assignment

volume = mesh
for i in range(0,nx_a):
    for j in range(0,ny_a):
        j_min = j-0.5
        j_max = j+0.5
        if (j_min<0): j_min=0
        if (j_max>ny-1): j_max=ny-1
        a = 0.5 if (i==0 or i==nx-1) else 1.0
        #note, this is y*dy for non-boundary nodes
        volume[i][j] = abs(a*dx*((j_max*dy)**2-(j_min*dy)**2))

for i in range(nx_a, nx_b): 
    ny_b = int(yval(i*dx)/dy)
    for j in range(0,ny_b):
        j_min = j-0.5
        j_max = j+0.5
        if (j_min<0): j_min=0
        if (j_max>ny-1): j_max=ny-1
        a = 0.5 if (i==0 or i==nx-1) else 1.0
        #note, this is y*dy for non-boundary nodes
        volume[i][j] = abs(a*dx*((j_max*dy)**2-(j_min*dy)**2))

nodelist = [] 
for i in range(nx): 
    nodelist.append(0)

def nodeno(nodelist): 
    global mesh
    for i in range(len(mesh)): 
        for j in range(len(mesh[i])):
            if j*dy <= yval(i*dx):# and volume[i][j] > 0:
                nodelist[i]+=1
nodeno(nodelist)


#----------------------------------GRAPHING----------------------------------#


pl.figure(figsize=(9, 3))
pl.xlabel('z(m)')
pl.ylabel('r(m)')
pl.title('Distribution of nodes in thruster setup')

xvals=[]
yvals=[]

for i in range(len(nodelist)): 
    for j in range(nodelist[i]): 
        xvals.append(i*dx)
        yvals.append(j*dy)
        
pl.plot(xvals,yvals, marker="o",  markersize=0)
pl.show()


#---------------------------------FUNCTIONS----------------------------------#


def velocity_assigner(vth):
    t = 2*math.pi*random.random()

    r = -1.0+2*random.random()
    a = math.sqrt(1-r*r)
    n = (math.cos(t)*a, math.sin(t)*a, r)
    
    #for maxwellian velocities
    v = np.zeros(2)
    v[0:2] = math.sqrt(2)*vth*(2*(random.random()+random.random()+random.random()-1.5))
    
    vel = [abs(n[0]*v[0]), n[1]*v[1]]
    return vel


def rebound(particle):
    x= particle.pos[0]
    y= particle.pos[1]
    b = yval(x)
 
    if y >= b and x<= tlen: 
        dif = y-b
        particle.pos[1] -= 2*dif
        particle.vel[1] = particle.vel[1]*-1
    elif y<=0 and x<=tlen: 
        dif = -1*y 
        particle.pos[1] += 2*dif 
        particle.vel[1] = particle.vel[1]*-1
    if x<0: 
        dif = -1*x
        particle.pos[0] = dif
        particle.vel[0] *= -1
        
        
def generator(species): 
    y = random.random() * 0.015  
    x = 0.48 # instead of 0, for quicker computation
    pos = [x,y]
    vel = velocity_assigner(species.vth)
    species.l.append(Particle(pos, vel))


rho = mesh
rhobar = 448516.58370602375 

def density(species): 
    global rho, volume, eps0, mesh
    rho = []
    for i in range(nx): 
        lx = [] 
        for j in range(ny): 
            lx.append(0)
        rho.append(lx)
    
    #rhobar = 0 
    for k in species.l:  
        i = math.floor(k.pos[0]/dx)
        j = math.floor(k.pos[1]/dy)
        hx = k.pos[0] - i*dx 
        hy = k.pos[1] - j*dy
        if j*dy <= yval(i*dx) and i<nx-1:
            rho[i][j]+=abs((dx-hx)*(dy-hy)/(dx*dy)*species.spwt)
            if rho[i][j] <0: 
                rho[i][j]=0
        if j*dy <= yval(i*dx) and i < nx-1:
            rho[i+1][j] += abs(hx * (dy-hy)/(dx*dy)*species.spwt)
            if rho[i+1][j] <0: 
                rho[i+1][j]=0
        if (j+1)*dy <= yval(i*dx) and i<nx-1:
            rho[i][j+1] += abs((dx-hx)*hy/(dx*dy)*species.spwt)
            if rho[i][j+1] <0: 
                rho[i][j+1]=0
        if (j+1)*dy <= yval(i*dx) and i < nx-1:
            rho[i+1][j+1] += abs(hx*hy/(dx*dy)*species.spwt)
            if rho[i+1][j+1] <0: 
                rho[i+1][j+1]=0
                
    
phi=mesh
def QNpotentialsolver(rho):  
    #Quasi-Neutral Boltzmann potential solver. QN Assumption; dx,dy >> ld
    global phi, rhobar
    phi = []
    for i in range(nx): 
        lx = [] 
        for j in range(ny): 
            lx.append(0)
        phi.append(lx)
    for i2 in range(len(phi)): 
        for j in range(len(phi[i2])): 
            if j*dy <= yval(i2*dx): 
                if rho[i2][j]<=0: 
                    phi[i2][j]=0
                else: 
                    phi[i2][j] = phi0 + (Kb*T)/q*math.log(rho[i2][j]/rhobar) 

  
efx = mesh
efy = mesh
def electric_field(phi): 
    global efx, efy
    for i in range(len(efy)):
        tn = nodelist[i] # no. of nodes in column
        for j in range(1,tn-1): 
            efy[i][j] = (phi[i][j-1] - phi[i][j+1])/(2*dy)
        efy[i][0] = (phi[i][0] - phi[i][1])/dy
        efy[i][tn-1] = (phi[i][tn-2] - phi[i][tn-2])/dy
            
    for i in range(1,len(efx)-1):
        tn = nodelist[i] # total no. of nodes in column
        for j in range(1, tn): 
            if j ==tn-1 and i>=500 and tn>nodelist[i-1]: 
                efx[i][tn-1] = (phi[i][tn-1] - phi[i+1][tn-1])/dx
                
            else:
                efx[i][j] = (phi[i-1][j] - phi[i+1][j])/(2*dx)

    for j in range(nodelist[0]): 
        efx[0][j] = (phi[0][j] - phi[1][j])/dx
    k = len(nodelist) - 1
    for j in range(nodelist[k]): 
        efx[k][j] = (phi[k-1][j] - phi[k][j])/dx
           

def updatevel(k, species): 
    global efx, efy
    i = math.floor(k.pos[0]/dx)
    j = math.floor(k.pos[1]/dy)

    hx = k.pos[0] - i*dx 
    hy = k.pos[1] - j*dy
    A = dx*dy
    if j<ny-1 and i<nx-1:
        ax = efx[i][j]*(dx-hx)*(dy-hy)/A + efx[i+1][j]*hx*(dy-hy)/A + efx[i][j+1]*(dx-hx)*hy/A + efx[i+1][j+1]*hx*hy/A
        ay = efy[i][j]*(dx-hx)*(dy-hy)/A + efy[i+1][j]*hx*(dy-hy)/A + efy[i][j+1]*(dx-hx)*hy/A + efy[i+1][j+1]*hx*hy/A
   
        ax = species.charge*ax/species.mass/10
        ay = species.charge*ay/species.mass/10
    else: 
        ax = ay = 0 
    return([ax,ay])


def push(particle, a):
    global dt 
    #x 
    particle.vel[0] += 0.5*a[0] * dt
    particle.pos[0] += particle.vel[0] * dt
    #y
    particle.vel[1] += 0.5*a[1] * dt
    particle.pos[1] += particle.vel[1] * dt
  
    
def ICRH(particle): 
    '''
    BASED ON FINDINGS IN
    Bering, Edgar & Brukardt, Michael & Squire, J. & Glover, Timothy & Jacobson, Verlin & McCaskill, Greg. 
    (2006). Recent Improvements In Ionization Costs and Ion Cyclotron Heating Efficiency in The VASMIR Engine. 
    Collection of Technical Papers - 44th AIAA Aerospace Sciences Meeting. 13. 10.2514/6.2006-766. '''
    if mi<6.9e-27:
        k= 0.5
        KE = 15 * eV_to_J
    elif mi<6.9e-26:
        k=1
        KE = 17 * eV_to_J
    else: 
        k=1
        KE = 19 * eV_to_J
    E = 2.7237e-18*10#J
    KE = (particle.vel[0]**2)/2*mi
    KE = 1/2*mi*(particle.vel[0]**2) + E
    
    particle.vel[0] = (2*KE/mi)**(1/2)*k
    particle.icrhcheck = True


def GEA(particle): 
    #Gridded Electrostatic Accelerator 
    k=0
    if mi <6.9e-27:
        k=1/3.3
    elif mi<6.9e-26:
        k=1/2.2
    else: 
        k= 0.7
    V = 1500
    KE = 1/2*mi*(particle.vel[0]**2) + q*V
    particle.vel[0] = (2*KE/mi)**(1/2)*k


v_ex = 0
vf_x = 0
vf_y = 0
n_ex = 1
Isp = 0


def vlogger(particle): 
    global v_ex, n_ex, vf_x, vf_y, Isp, geacount
    GEA(particle)
    vf_x = ((n_ex-1)*vf_x + particle.vel[0])/n_ex
    vf_y = ((n_ex-1)*vf_y + particle.vel[1])/n_ex
    v_ex = ((n_ex-1)*v_ex + (particle.vel[0]**2 + particle.vel[1]**2)**(1/2))/n_ex
    n_ex+=1
    Isp = v_ex/9.806
    
    
#------------------------------------LOOP------------------------------------#   


ions= Species(mi, spwt, q, vth_i)
counter = 1
loopcount= 100000


for i in range(loopcount):
    for i in range(pdot):
        generator(ions)
    k = len(ions.l)
    if k>0:
        j=0
        while j<k: 
            ICRH(ions.l[j])
            push(ions.l[j], updatevel(ions.l[j], ions))
            if ions.l[j].pos[0]>tlen: 
                vlogger(ions.l[j])
                del ions.l[j] 
                
                k-=1 
                j-=1
            else: 
                rebound(ions.l[j])
                rebound(ions.l[j])
            
            j+=1
        
        density(ions)
        rhocopy = rho
        QNpotentialsolver(rhocopy)
        efx = mesh
        efy = mesh
        electric_field(phi)

    if (i+1)*100/loopcount == int ((i+1)*100/loopcount): 
        print(str(int ((i+1)*100/loopcount))+'%')
        
        
#----------------------------------READINGS----------------------------------# 


print('Exit velocity: ', round(v_ex, 1) , 'm/s')
print('Specific Impulse (Isp): ', round(Isp, 1), 's')
print('vx = ', vf_x, 'm/s')
print('vy = ', vf_y, 'm/s')
print('number of ion particle class exits: ', n_ex -1)
print("--- %s seconds ---" % (round(time.time() - start_time,1)))  


#----------------------------------------------------------------------------# 
